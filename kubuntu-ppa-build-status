#!/usr/bin/python

import argparse
import cgi
import datetime
import gzip
import json
from launchpadlib.launchpad import Launchpad
import os
import re
import sys
import time

parser = argparse.ArgumentParser(description="Generate a build status report.")
parser.add_argument("-d", "--dist", required=True, help="Distribution name")
parser.add_argument("-v", "--version", required=True, help="Upstream version")
parser.add_argument("-c", "--credentials", help="Location of the credenticals file")
parser.add_argument("--cache", default="cache", help="Directory where the cahce is stored")

args = parser.parse_args()

release = args.dist
version = args.version

STATUS_SUCCESS = 0
STATUS_WARNING = 1
STATUS_ERROR = 2
STATUS_BUILDING = -1
STATUS_WAITING = -2

def get_log(build):
    buildId = int(build.self_link[build.self_link.rfind("/") + 1:])
    cacheFilename = args.cache + "/buildlogs/" + str(buildId) + ".gz"

    if os.path.isfile(cacheFilename):
        f = gzip.GzipFile(cacheFilename, "r")
        content = f.read()
        f.close()
        return content

    url = build.build_log_url
    # hack to get build log for private PPAs
    url = url.replace("https://launchpad.net/", "https://api.launchpad.net/1.0/")
    try:
        content = lp._browser.get(url)
    except:
        time.sleep(5)
        content = lp._browser.get(url)

    if build.buildstate == "Successfully built":
        f = gzip.GzipFile(cacheFilename, "w")
        f.write(content)
        f.close()

    return content

def isCmakeDepIgnored(depLine, package):
    if not package in cmakeIgnore:
        return False

    for dep in cmakeIgnore[package]:
        if depLine.startswith(dep):
            return True

    return False

def get_cmake(log, package):
    try:
        start = log.index("\ndh_auto_configure") + 1
    except ValueError:
        start = log.index("\n   dh_auto_configure") + 1
    end = log.rindex("\n", 0, log.index("dh_auto_build")) - 1
    cmakeLog = log[start:end]
    logLines = cmakeLog.splitlines()
    highlightLines = set()

    if "The following OPTIONAL packages could NOT be located" in cmakeLog:
        startMsg = False
        startLine = False
        numIgnored = 0
        numNotIgnored = 0
        for i, line in enumerate(logLines):
            if not startMsg and "The following OPTIONAL packages could NOT be located" in line:
                startMsg = True
            elif startMsg and not startLine and "--------------------------------" in line:
                startLine = True
            elif startMsg and startLine:
                if "--------------------------------" in line:
                    break
                match = re.search(r'^ *\* (.*)$', line)
                if match:
                    ignore = isCmakeDepIgnored(match.group(1), package)
                    if ignore:
                        numIgnored += 1
                    else:
                        numNotIgnored += 1
                        highlightLines.add(i)

        if numIgnored == 0 and numNotIgnored == 0:
            # how could this happen?!
            status = STATUS_ERROR
        elif numNotIgnored != 0:
            status = STATUS_WARNING
        else:
            status = STATUS_SUCCESS
    elif "All external packages have been found" in cmakeLog:
        status = STATUS_SUCCESS
    elif ("Could NOT find" in cmakeLog) or ("Could not find a package configuration file provided by" in cmakeLog):
        numIgnored = 0
        numNotIgnored = 0
        for i, line in enumerate(logLines):
            pos = line.find("Could NOT find")
            if pos != -1:
                pos += 15
            else:
                pos = line.find("Could not find a package configuration file provided by \"")
                if pos != -1:
                    pos += 57
                else:
                    continue
            ignore = isCmakeDepIgnored(line[pos:], package)
            if ignore:
                numIgnored += 1
            else:
                numNotIgnored += 1
                highlightLines.add(i)
        if numIgnored == 0 and numNotIgnored == 0:
            # how could this happen?!
            status = STATUS_ERROR
        elif numNotIgnored != 0:
            status = STATUS_WARNING
        else:
            status = STATUS_SUCCESS
    else:
        status = STATUS_SUCCESS

    for i, line in enumerate(logLines):
        if "CMake Warning" in line:
            if "CMake Warning at /usr/share/kde4/apps/cmake/modules/MacroOptionalFindPackage.cmake" in line:
                continue
            if re.search(r'CMake Warning at [^ :]+:\d+ \(find_package\)', line):
                continue

            if status == STATUS_SUCCESS:
                status = STATUS_WARNING
            highlightLines.add(i)

    for i, line in enumerate(logLines):
        line = cgi.escape(line)
        if i in highlightLines:
            line = "<b>" + line + "</b>"
        logLines[i] = line

    return ("\n".join(logLines), status)

def get_symbols(log):
    if "dpkg-gensymbols: warning: some symbols or patterns disappeared in the symbols file" in log:
        status = STATUS_ERROR
    elif "dpkg-gensymbols: warning: some new symbols appeared in the symbols file" in log:
        status = STATUS_WARNING
    else:
        status = STATUS_SUCCESS

    return ("", status)

def get_list_missing(log):
    start = log.index("=== Start list-missing") + 22
    end = log.index("=== End list-missing")
    output = log[start:end].strip("\r\n\t ")
    if output:
        status = STATUS_ERROR
    else:
        status = STATUS_SUCCESS

    return (output, status)

def get_dh_list_missing(log):
    output = []
    if "exists in debian/tmp but is not installed to anywhere" in log:
        logLines = log.splitlines()
        for line in logLines:
            match = re.search(r'dh_install: (.*) exists in debian/tmp but is not installed to anywhere', line)
            if match:
                output.append(match.group(1))

    if not output:
        status = STATUS_SUCCESS
    else:
        status = STATUS_ERROR

    return ("\n".join(output), status)

def get_depwait(log):
    output = []
    unsatisfied = False
    for line in log.splitlines():
        if re.search('Unable to locate package', line):
            output.append(re.sub('E: Unable to locate package ', '', line))

        if re.search('has no installation candidate', line):
            l = re.sub(".*?'", '', line, count=1)
            l = re.sub("'.*", '', l)
            output.append(l)

        if unsatisfied:
            pkgname = True
            for res in re.split('\(|\)', line):
                if pkgname:
                    # package name
                    output.append(res)
                    pkgname = False
                else:
                    versionlist = res.split(' ')
                    output.append(" >= " + versionlist[len(versionlist) - 1] + " ")
                    pkgname = True
            break
        if re.match('After installing, the following source dependencies are still unsatisfied:', line):
            unsatisfied = True

    return "\n".join(output)


if args.credentials:
    lp = Launchpad.login_with("kubuntu-ppa-build-status", "production", args.cache, credentials_file=args.credentials)
else:
    lp = Launchpad.login_with("kubuntu-ppa-build-status", "production", args.cache)

ubuntu = lp.distributions["ubuntu"]
lpseries = ubuntu.getSeries(name_or_version=release)

ppa = lp.people["kubuntu-ninjas"].getPPAByName(name="ppa")

f = open("cmake-ignore.json", "r")
cmakeIgnore = json.load(f)
f.close()

if not os.path.isdir(args.cache + "/buildlogs"):
    os.mkdir(args.cache + "/buildlogs")

print """
<html>

<head>
  <title>Kubuntu KDE status</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="kubuntu-ppa-build-status.css" />

<script type="text/javascript">
<!--
    function toggleVisibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
          e.style.display = 'block';

       return false;
    }
//-->
</script>

</head>

<body>

<h1 id="top">Kubuntu KDE %s -> %s status</h1>

<table class="grid">

<thead><tr>
  <th>Package</th>
  <th>Arch</th>
  <th>Log</th>
  <th>Status messages</th>
  </tr></thead>

  <tbody>
""" % (version, release)

builds = {}

for source in ppa.getPublishedSources(distro_series=lpseries, status="Published"):
    package = source.source_package_name
    packageVersion = source.source_package_version
    if not (packageVersion.startswith("4:" + version) or packageVersion.startswith(version)):
        continue

    if package in builds:
        print "Error multiple versions of the same package"
        sys.exit(1)

    builds[package] = {}

    for build in source.getBuilds():
        arch = build.arch_tag
        builds[package][arch] = {}

        builds[package][arch]["logfile"] = build.build_log_url
        builds[package][arch]["version"] = packageVersion

        if build.buildstate == "Successfully built":
            log = get_log(build)

            builds[package][arch]["status"] = STATUS_SUCCESS
            builds[package][arch]["message"] = ""

            output, status = get_symbols(log)
            if status == STATUS_ERROR:
                msg = "Missing symbols"
            elif status == STATUS_WARNING:
                msg = "New symbols"

            if status != STATUS_SUCCESS:
                builds[package][arch]["message"] += "<h3>symbol files:</h3>\n<div style=\"font-weight: bold;\">" + msg + "</div>\n"
            builds[package][arch]["status"] = max(status, builds[package][arch]["status"])

            try:
                output, status = get_list_missing(log)
            except ValueError:
                if (arch == "i386") and not (("--list-missing" in log) or ("--fail-missing" in log)):
                    status = STATUS_WARNING
                    output = "No list-missing in build log."
                else:
                    status = STATUS_SUCCESS
            if status != STATUS_SUCCESS:
                builds[package][arch]["message"] += "<h3>list-missing:</h3>\n<pre>" + cgi.escape(output) + "</pre>\n"
            builds[package][arch]["status"] = max(status, builds[package][arch]["status"])

            output, status = get_dh_list_missing(log)
            if status != STATUS_SUCCESS:
                builds[package][arch]["message"] += "<h3>list-missing:</h3>\n<pre>" + cgi.escape(output) + "</pre>\n"
            builds[package][arch]["status"] = max(status, builds[package][arch]["status"])

            output, status = get_cmake(log, package)
            builds[package][arch]["message"] += "<h3>cmake:</h3>\n<pre>" + output + "</pre>\n"
            builds[package][arch]["status"] = max(status, builds[package][arch]["status"])
        elif build.buildstate == "Needs building":
            builds[package][arch]["status"] = STATUS_WAITING
            builds[package][arch]["message"] = build.buildstate
        elif build.buildstate == "Dependency wait":
            builds[package][arch]["status"] = STATUS_WAITING
            try:
                builds[package][arch]["message"] = build.buildstate + ": " + get_depwait(get_log(build))
            except AttributeError:
                builds[package][arch]["message"] = build.buildstate
        elif build.buildstate == "Currently building" or build.buildstate == "Uploading build":
            builds[package][arch]["status"] = STATUS_BUILDING
            builds[package][arch]["message"] = build.buildstate
        elif build.buildstate == "Failed to build":
            try:
                log = get_log(build)
                if log.find("kde-sc-dev-latest : Breaks:") != -1:
                    builds[package][arch]["status"] = STATUS_WAITING
                    builds[package][arch]["message"] = "Dependency wait"
                else:
                    builds[package][arch]["status"] = STATUS_ERROR
                    builds[package][arch]["message"] = build.buildstate
            except AttributeError:
                # fetching the log fails when launchpad fails the build for
                # internal reasons
                builds[package][arch]["status"] = STATUS_ERROR
                builds[package][arch]["message"] = build.buildstate
        else:
            builds[package][arch]["status"] = STATUS_ERROR
            builds[package][arch]["message"] = build.buildstate


odd = True
i = 1

for package in sorted(builds.iterkeys()):
    for arch in builds[package]:
        build = builds[package][arch]

        if odd:
            trclass = "odd"
            odd = False
        else:
            trclass = "even"
            odd = True

        message = build["message"]
        if len(message) > 100:
            message = '<a href="#" onclick="return toggleVisibility(\'msg-%d\')">show/hide</a><div id="msg-%d" style="display:none;">%s</div>' % (i, i, message)

        print '<tr class="%s"><td class="status%d"><span title="%s">%s</span></td><td>%s</td>' % (trclass, build["status"], cgi.escape(build["version"]), package, arch)
        if build["logfile"]:
            print '<td><a href="%s">logfile</a></td>' % (build["logfile"],)
        else:
            print '<td>&nbsp;</td>'
        print '<td>%s</td></tr>\n' % (message,)

        i += 1

print """
</tbody>

</table>
"""

print "<br/><div>Last updated on %s (UTC)</div>\n" % datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M")

print """
</body>
</html>
"""

# kate: space-indent on; indent-width 4; replace-tabs on; indent-mode python; remove-trailing-space on;
